// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: report.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createReportUser = `-- name: CreateReportUser :exec
INSERT INTO reports (
  id,
  user_id,
  period,
  total_income,
  total_expense
)
SELECT
  $2, -- ID passed as a parameter
  t.user_id,
  'Daily',
  SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE 0 END),
  SUM(CASE WHEN t.type = 'expense' THEN t.amount ELSE 0 END)
FROM transaction t
WHERE t.user_id = $1
AND t.created_at BETWEEN NOW() - INTERVAL '1 day' AND NOW()
GROUP BY t.user_id
`

type CreateReportUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) CreateReportUser(ctx context.Context, arg CreateReportUserParams) error {
	_, err := q.db.Exec(ctx, createReportUser, arg.UserID, arg.ID)
	return err
}

const getDetailsReportbyUser = `-- name: GetDetailsReportbyUser :many
SELECT t.id, t.user_id, t.category_id, c.name AS category_name, t.amount, t.description, t.created_at
FROM transaction t
JOIN categories c ON t.category_id = c.id
WHERE t.user_id = $1
ORDER BY t.created_at DESC
`

type GetDetailsReportbyUserRow struct {
	ID           uuid.UUID `json:"id"`
	UserID       uuid.UUID `json:"user_id"`
	CategoryID   uuid.UUID `json:"category_id"`
	CategoryName string    `json:"category_name"`
	Amount       int64     `json:"amount"`
	Description  string    `json:"description"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) GetDetailsReportbyUser(ctx context.Context, userID uuid.UUID) ([]GetDetailsReportbyUserRow, error) {
	rows, err := q.db.Query(ctx, getDetailsReportbyUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDetailsReportbyUserRow{}
	for rows.Next() {
		var i GetDetailsReportbyUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.CategoryName,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportbyCategory = `-- name: GetReportbyCategory :many
SELECT c.name AS category_name,
       SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE 0 END) AS total_income,
       SUM(CASE WHEN t.type = 'expense' THEN t.amount ELSE 0 END) AS total_expense
FROM transaction t
JOIN categories c ON t.category_id = c.id
GROUP BY c.name
`

type GetReportbyCategoryRow struct {
	CategoryName string `json:"category_name"`
	TotalIncome  int64  `json:"total_income"`
	TotalExpense int64  `json:"total_expense"`
}

func (q *Queries) GetReportbyCategory(ctx context.Context) ([]GetReportbyCategoryRow, error) {
	rows, err := q.db.Query(ctx, getReportbyCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportbyCategoryRow{}
	for rows.Next() {
		var i GetReportbyCategoryRow
		if err := rows.Scan(&i.CategoryName, &i.TotalIncome, &i.TotalExpense); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportbyDate = `-- name: GetReportbyDate :many
SELECT t.id, t.user_id, t.category_id, c.name AS category_name, t.amount, t.type, t.description, t.created_at
FROM transaction t
JOIN categories c ON t.category_id = c.id
WHERE t.user_id = $1
AND t.created_at BETWEEN $2 AND $3
ORDER BY t.created_at DESC
`

type GetReportbyDateParams struct {
	UserID      uuid.UUID `json:"user_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetReportbyDateRow struct {
	ID           uuid.UUID `json:"id"`
	UserID       uuid.UUID `json:"user_id"`
	CategoryID   uuid.UUID `json:"category_id"`
	CategoryName string    `json:"category_name"`
	Amount       int64     `json:"amount"`
	Type         string    `json:"type"`
	Description  string    `json:"description"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) GetReportbyDate(ctx context.Context, arg GetReportbyDateParams) ([]GetReportbyDateRow, error) {
	rows, err := q.db.Query(ctx, getReportbyDate, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportbyDateRow{}
	for rows.Next() {
		var i GetReportbyDateRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.CategoryName,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportbyUser = `-- name: GetReportbyUser :one
SELECT user_id, 
       SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) AS total_income,
       SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) AS total_expense
FROM transaction
WHERE user_id = $1
GROUP BY user_id
`

type GetReportbyUserRow struct {
	UserID       uuid.UUID `json:"user_id"`
	TotalIncome  int64     `json:"total_income"`
	TotalExpense int64     `json:"total_expense"`
}

func (q *Queries) GetReportbyUser(ctx context.Context, userID uuid.UUID) (GetReportbyUserRow, error) {
	row := q.db.QueryRow(ctx, getReportbyUser, userID)
	var i GetReportbyUserRow
	err := row.Scan(&i.UserID, &i.TotalIncome, &i.TotalExpense)
	return i, err
}
