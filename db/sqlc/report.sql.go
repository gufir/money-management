// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: report.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createMonthlyReport = `-- name: CreateMonthlyReport :exec
INSERT INTO reports (
  id,
  user_id,
  period,
  total_income,
  total_expense
)
SELECT
  uuid_generate_v4(),  -- New ID generated for the report
  t.user_id,
  'Monthly',
  SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE 0 END),
  SUM(CASE WHEN t.type = 'expense' THEN t.amount ELSE 0 END)
FROM transaction t
WHERE t.user_id = $1
AND t.created_at BETWEEN DATE_TRUNC('month', NOW()) AND NOW()
GROUP BY t.user_id
`

func (q *Queries) CreateMonthlyReport(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, createMonthlyReport, userID)
	return err
}

const createReportUser = `-- name: CreateReportUser :exec
INSERT INTO reports (
  id,
  user_id,
  period,
  total_income,
  total_expense
)
SELECT
  $2, -- ID passed as a parameter
  t.user_id,
  'Daily',
  SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE 0 END),
  SUM(CASE WHEN t.type = 'expense' THEN t.amount ELSE 0 END)
FROM transaction t
WHERE t.user_id = $1
AND t.created_at BETWEEN NOW() - INTERVAL '1 day' AND NOW()
GROUP BY t.user_id
`

type CreateReportUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) CreateReportUser(ctx context.Context, arg CreateReportUserParams) error {
	_, err := q.db.Exec(ctx, createReportUser, arg.UserID, arg.ID)
	return err
}

const getDetailsReportByUser = `-- name: GetDetailsReportByUser :many
SELECT t.id, t.user_id, t.amount, t.description, t.created_at
FROM transaction t
WHERE t.user_id = $1
ORDER BY t.created_at DESC
`

type GetDetailsReportByUserRow struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"user_id"`
	Amount      int64     `json:"amount"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) GetDetailsReportByUser(ctx context.Context, userID uuid.UUID) ([]GetDetailsReportByUserRow, error) {
	rows, err := q.db.Query(ctx, getDetailsReportByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDetailsReportByUserRow{}
	for rows.Next() {
		var i GetDetailsReportByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportByCategory = `-- name: GetReportByCategory :many
SELECT t.category_id,
       SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE 0 END) AS total_income,
       SUM(CASE WHEN t.type = 'expense' THEN t.amount ELSE 0 END) AS total_expense
FROM transaction t
GROUP BY t.category_id
`

type GetReportByCategoryRow struct {
	CategoryID   uuid.UUID `json:"category_id"`
	TotalIncome  int64     `json:"total_income"`
	TotalExpense int64     `json:"total_expense"`
}

func (q *Queries) GetReportByCategory(ctx context.Context) ([]GetReportByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getReportByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportByCategoryRow{}
	for rows.Next() {
		var i GetReportByCategoryRow
		if err := rows.Scan(&i.CategoryID, &i.TotalIncome, &i.TotalExpense); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportByDate = `-- name: GetReportByDate :many
SELECT t.id, t.user_id, t.amount, t.type, t.description, t.created_at
FROM transaction t
WHERE t.user_id = $1
AND t.created_at BETWEEN $2 AND $3
ORDER BY t.created_at DESC
`

type GetReportByDateParams struct {
	UserID      uuid.UUID `json:"user_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetReportByDateRow struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"user_id"`
	Amount      int64     `json:"amount"`
	Type        string    `json:"type"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) GetReportByDate(ctx context.Context, arg GetReportByDateParams) ([]GetReportByDateRow, error) {
	rows, err := q.db.Query(ctx, getReportByDate, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportByDateRow{}
	for rows.Next() {
		var i GetReportByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportByUser = `-- name: GetReportByUser :one
SELECT user_id, 
       SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) AS total_income,
       SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) AS total_expense
FROM transaction
WHERE user_id = $1
GROUP BY user_id
`

type GetReportByUserRow struct {
	UserID       uuid.UUID `json:"user_id"`
	TotalIncome  int64     `json:"total_income"`
	TotalExpense int64     `json:"total_expense"`
}

func (q *Queries) GetReportByUser(ctx context.Context, userID uuid.UUID) (GetReportByUserRow, error) {
	row := q.db.QueryRow(ctx, getReportByUser, userID)
	var i GetReportByUserRow
	err := row.Scan(&i.UserID, &i.TotalIncome, &i.TotalExpense)
	return i, err
}
